## Level 4: See TDD Catch Real AI Mistakes

| Level 0 | Level 1 |   Level 2    | Level 3 |    Level 4    |    Level 5     | Start |
| :-----: | :-----: | :----------: | :-----: | :-----------: | :------------: | :---: |
|   ‚úÖ    |   ‚úÖ    |      ‚úÖ      |   ‚úÖ    |  üìç **YOU**   |       ‚è∏Ô∏è       |  ‚è∏Ô∏è   |
| Problem | Mindset | How It Works | Visual  | **TDD Value** | **Essentials** | Setup |

**‚è±Ô∏è Time: 15 minutes**

> üì∑ **[Visual Placeholder]**: Split-screen illustration. LEFT (red/orange chaos): AI robot enthusiastically generating excessive code with floating validation rules creating chaos, labeled "Without AAID." RIGHT (blue/green calm): Same AI robot working within structured TDD framework, generating clean minimal code with green checkmark, labeled "With AAID." Professional graphic style with clear contrast.

Let's see a real scenario where AI tries to be "helpful" but TDD discipline saves you from shipping bugs and over-engineering.

### The Specification

```gherkin
User Story:
As a user, I want my password to be validated for basic security

Scenario 1: Password must be at least 8 characters
  Given I'm creating a new account
  When I enter a password with less than 8 characters
  Then I should see an error "Password must be at least 8 characters"

Scenario 2: Password must contain a number
  Given I'm creating a new account
  When I enter a password without any numbers
  Then I should see an error "Password must contain a number"
```

---

### The Risk: What Happens Without TDD Discipline

When AI generates code without TDD constraints, it tends to be "helpful" beyond the specification:

**Developer**: _"AI, implement password validation"_

**AI without constraints**: _"Here's a comprehensive solution:"_

```typescript
type ValidationResult = { isValid: boolean; errors: string[] }

class PasswordValidator {
  validate(password: string): ValidationResult {
    const errors = []

    // Length check (actually in specification)
    if (password.length < 8) {
      errors.push("Password must be at least 8 characters")
    }

    // AI adds these without being asked!
    if (!/[A-Z]/.test(password)) {
      errors.push("Password must contain an uppercase letter")
    }

    if (!/[0-9]/.test(password)) {
      errors.push("Password must contain a number")
    }

    if (!/[!@#$%^&*]/.test(password)) {
      errors.push("Password must contain a special character")
    }

    // Even more "helpful" additions
    if (password.length > 64) {
      errors.push("Password too long")
    }

    if (this.isCommonPassword(password)) {
      errors.push("Password is too common")
    }

    return { isValid: errors.length === 0, errors }
  }

  private isCommonPassword(password: string): boolean {
    const commonPasswords = ["password", "12345678" /* ... */]
    return commonPasswords.includes(password.toLowerCase())
  }
}
```

**The problems:**

- ‚ùå Spec asked for 8-character minimum only
- ‚ùå AI added 5 extra validation rules
- ‚ùå Untested edge cases shipped to production
- ‚ùå Users complain their valid passwords are rejected
- ‚ùå Business never approved these rules

You've shipped untested, unapproved features breaking real users. Passwords like `"simplepass"` were perfectly valid per the actual requirement.

---

### How AAID Enforces TDD Discipline

Now let's see the same scenario with AAID rules guiding the AI through proper TDD.

**Our test list** (derived from the BDD scenarios):

```typescript
describe("PasswordValidator", () => {
  it.skip("should reject password shorter than 8 characters")
  it.skip("should accept password with 8 or more characters")
  it.skip("should reject password without a number")
})
```

We'll un-skip and implement these one at a time through RED ‚Üí GREEN ‚Üí REFACTOR cycles. Watch how the tests drive minimal, focused code.

---

## üîÑ Cycle 1: First Test (Invalid Password)

### üî¥ RED: Write Failing Test

**AAID instructs**: "Un-skip the first test from your list and implement it. Test BEHAVIOR, not implementation."

```typescript
describe("PasswordValidator", () => {
  it("should reject password shorter than 8 characters", () => {
    // Given
    const validator = new PasswordValidator()
    const shortPassword = "abc123"

    // When
    const result = validator.validate(shortPassword)

    // Then
    expect(result.isValid).toBe(false)
    expect(result.errors).toContain("Password must be at least 8 characters")
  })
})
```

**Run test**: ‚ùå Fails (PasswordValidator doesn't exist)

**‚è∏Ô∏è REVIEW**: Does test match spec exactly? ‚úì | Any extra requirements? No ‚úì

---

### üü¢ GREEN: Make It Pass (The Simplest Way Possible)

**AAID instructs**: "Write MINIMUM code to pass. Don't generalize yet. Fake it if needed."

**AI generates**:

```typescript
type ValidationResult = { isValid: boolean; errors: string[] }

class PasswordValidator {
  validate(password: string): ValidationResult {
    return {
      isValid: false,
      errors: ["Password must be at least 8 characters"]
    }
  }
}
```

**Run tests**: ‚úÖ All pass

**Why hardcode?** With only ONE test, we don't know what the general pattern is yet. This is Kent Beck's "Fake It" principle: hardcode until tests force you to generalize.

**‚è∏Ô∏è REVIEW**: Test passes? ‚úì | No untested code? ‚úì | Truly minimal? ‚úì

---

### üßº REFACTOR: Improve Code Quality

**AAID instructs**: "Evaluate for improvements. With passing tests as safety net, clean up if needed."

**Evaluation**: No duplication, no complexity. Nothing to refactor yet.

**‚è∏Ô∏è REVIEW**: Tests still green? ‚úì | No new behavior? ‚úì

---

## üîÑ Cycle 2: Second Test (Valid Password)

This is where the magic happens. Watch how the second test **forces** better code.

### üî¥ RED: Add Test for Valid Password

Un-skip the second test from the list:

```typescript
describe("PasswordValidator", () => {
  // ... previous test ...

  it("should accept password with 8 or more characters", () => {
    // Given
    const validator = new PasswordValidator()
    const validPassword = "abcd1234"

    // When
    const result = validator.validate(validPassword)

    // Then
    expect(result.isValid).toBe(true)
    expect(result.errors).toEqual([])
  })
})
```

**Run tests**: ‚ùå New test fails (hardcoded response always returns invalid)

**‚è∏Ô∏è REVIEW**: Covers new scenario? ‚úì | Still focused on spec? ‚úì

---

### üü¢ GREEN: Now We Need Real Logic

**AAID instructs**: "Hardcoded response no longer works. Write actual logic to make BOTH tests pass."

This is **triangulation**: two examples pointing to the general pattern.

**AI generates**:

```typescript
type ValidationResult = { isValid: boolean; errors: string[] }

class PasswordValidator {
  validate(password: string): ValidationResult {
    const errors: string[] = []

    if (password.length < 8) {
      errors.push("Password must be at least 8 characters")
    }

    return { isValid: errors.length === 0, errors }
  }
}
```

**Run tests**: ‚úÖ Both tests pass

**The "aha!" moment**: The second test **forced** us to write actual validation logic. Not because we were clever, but because we had no choice.

**‚è∏Ô∏è REVIEW**: Both tests pass? ‚úì | No untested features? ‚úì | Logic matches spec? ‚úì

---

### üßº REFACTOR: Still Clean

**Evaluation**: Code is clear and simple. No duplication. No complexity. Nothing to improve yet.

**‚è∏Ô∏è REVIEW**: Tests green? ‚úì

---

**üí° The TDD boundary at work**: We've completed Scenario 1 (length validation). Notice what's **NOT** in our code:

- ‚ùå No uppercase requirement (wasn't in spec)
- ‚ùå No special character requirement (wasn't in spec)
- ‚ùå No "common password" check (wasn't in spec)
- ‚ùå No max length limit (wasn't in spec)

Without TDD, the AI added all of these "helpfully." With TDD, the test defines the boundary. No test? No code.

---

**Progress check**: You've completed the first two items from your test list:

```typescript
describe("PasswordValidator", () => {
  ‚úÖ it("should reject password shorter than 8 characters")
  ‚úÖ it("should accept password with 8 or more characters")
  it.skip("should reject password without a number")  // ‚Üê Next
})
```

The code is clean, all tests pass. In real TDD, you check these off and move to the next item. Let's un-skip the third test.

---

## üîÑ Cycle 3: Next Scenario from the Spec

Time to implement Scenario 2: "Password must contain at least one number."

### üî¥ RED: Add Test for Number Validation

Un-skip the third test from the list:

```typescript
describe("PasswordValidator", () => {
  // ... previous tests ...

  it("should reject password without a number", () => {
    // Given
    const validator = new PasswordValidator()
    const passwordWithoutNumber = "abcdefgh"

    // When
    const result = validator.validate(passwordWithoutNumber)

    // Then
    expect(result.isValid).toBe(false)
    expect(result.errors).toContain("Password must contain a number")
  })
})
```

**Run tests**: ‚ùå New test fails

**‚è∏Ô∏è REVIEW**: Matches new requirement? ‚úì

---

### üü¢ GREEN: Add Number Check (Duplication Emerges)

```typescript
type ValidationResult = { isValid: boolean; errors: string[] }

class PasswordValidator {
  validate(password: string): ValidationResult {
    const errors: string[] = []

    if (password.length < 8) {
      errors.push("Password must be at least 8 characters")
    }

    if (!/[0-9]/.test(password)) {
      errors.push("Password must contain a number")
    }

    return { isValid: errors.length === 0, errors }
  }
}
```

**Run tests**: ‚úÖ All pass

**Notice the smell**: Two if statements following the same pattern. This is duplication. Time to refactor.

**‚è∏Ô∏è REVIEW**: All tests green? ‚úì | See the duplication? ‚úì

---

### üßº REFACTOR: Developer Guides the Abstraction

You recognize the pattern and guide the AI:

**Your guidance**: _"Make it easy to extend. Extract validation rules to private methods, no mutations, add an interface for the validation methods."_

> üí° You're explicit here to teach the AI your design preferences, as it didn't extract it from the provided context already.

**AI refactors**:

```typescript
type ValidationResult = { isValid: boolean; errors: string[] }
type ValidationRule = (password: string) => string | undefined

class PasswordValidator {
  validate(password: string): ValidationResult {
    const errors = [
      this.validateLength(password),
      this.validateNumber(password)
    ].filter(error => error !== undefined) as string[]

    return { isValid: errors.length === 0, errors }
  }

  private validateLength: ValidationRule = password => {
    return password.length < 8
      ? "Password must be at least 8 characters"
      : undefined
  }

  private validateNumber: ValidationRule = password => {
    return !/[0-9]/.test(password)
      ? "Password must contain a number"
      : undefined
  }
}
```

**Run tests**: ‚úÖ All still pass

**The transformation**:

- Extracted common pattern into `ValidationRule` type
- Each rule is a pure function returning `string | undefined`
- Clean filter pipeline removes `undefined` values
- Adding future rules is now trivial: just add another method to the array

**‚è∏Ô∏è REVIEW**: Tests green? ‚úì | No new behavior? ‚úì | Cleaner? ‚úì

**The key insight**: You abstracted **because duplication appeared**, not because you anticipated it. The tests forced the pattern to emerge naturally.

---

## The Result: All Problems Solved

Remember the chaos from "Without TDD Discipline"? Here's how AAID solved each problem:

| Problem                       | Without AAID                                          | With AAID                                            |
| ----------------------------- | ----------------------------------------------------- | ---------------------------------------------------- |
| **Spec adherence**            | ‚ùå Spec asked for length only, AI added 5 extra rules | ‚úÖ Implemented only what's in spec (length + number) |
| **Testing coverage**          | ‚ùå Untested code shipped to production                | ‚úÖ Every line tested before shipping                 |
| **User impact**               | ‚ùå Valid passwords like "simplepass" rejected         | ‚úÖ All spec-compliant passwords work                 |
| **Unauthorized features**     | ‚ùå Business never approved these rules                | ‚úÖ Only implements spec-approved requirements        |
| **Code quality & complexity** | ‚ùå 50+ lines with unnecessary features                | ‚úÖ 20 lines of clean, focused code                   |

**This demonstrates the Three Laws of TDD:**

1. **Write no production code without a failing test** ‚Üí Prevented unapproved features
2. **Write only enough test code to fail** ‚Üí Kept tests focused on spec scenarios
3. **Write only enough production code to pass** ‚Üí Stopped over-engineering

Test defines the boundary. No test? No code.

---

## Why Review Checkpoints Still Matter

You might wonder: _"If AAID rules prevent over-engineering, why review?"_

Think of it like spell-check: AAID rules catch most issues automatically (85-95% of the time), but your reviews ensure 100% quality. When deviations happen, you catch them before they ship. That's the safety net working as designed.

---

**üõë Checkpoint**: See how TDD discipline guards against AI over-engineering?

- **"Yes, this makes sense!"** ‚Üí Continue to [Level 5](./5.md) for next steps
- **"I want to try this"** ‚Üí Jump to [Get Started](./get-started.md) for setup
- **"Show me the workflow again"** ‚Üí Review [Level 3](./3.md)

> üéØ **Key Insight**: You're not limiting AI's helpfulness; you're focusing it. AAID rules teach the AI TDD discipline, your reviews verify alignment, and together they ensure AI moves fast in the RIGHT direction. That's the power of augmentation over autonomy.

---

‚úÖ **Progress: 75% complete** | Next: Level 5 (5 minutes) - What's Next?

---

‚¨ÖÔ∏è Back to [AAID Onboarding Guide](../guide.md)
