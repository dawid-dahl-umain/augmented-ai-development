## Level 4: See TDD Catch AI Mistakes

| Level 0 | Level 1 |   Level 2    | Level 3 |      Level 4       |  Level 5  |  Level 6  | Start |
| :-----: | :-----: | :----------: | :-----: | :----------------: | :-------: | :-------: | :---: |
|   ‚úÖ    |   ‚úÖ    |      ‚úÖ      |   ‚úÖ    |     üìç **YOU**     |    ‚è∏Ô∏è     |    ‚è∏Ô∏è     |  ‚è∏Ô∏è   |
| Problem | Mindset | How It Works | Visual  | **TDD Catches AI** | Your Work | Demo Repo | Ready |

**‚è±Ô∏è Time: 20 minutes**

![See TDD Catch AI Mistakes](../../../assets/onboarding/4.webp)

**In this level:**

- [The Specification](#the-specification)
- [The Risk: Without TDD](#the-risk-what-happens-without-tdd-discipline)
- [How AAID Enforces TDD](#how-aaid-enforces-tdd-discipline)
- [Cycle 1: First Test](#cycle-1)
- [Cycle 2: Test Custom Minimum Length](#cycle-2)
- [Cycle 3: Valid Password Test](#cycle-3)
- [Cycle 4: Number Validation Test](#cycle-4)
- [The Result: Problems Solved](#the-result-all-problems-solved)

---

Let's see a real scenario where AI tries to be "helpful" but TDD discipline saves you from shipping bugs and over-engineering.

### The Specification

```gherkin
User Story:
As a user, I want my password to be validated for basic security

Scenario 1: Password must be at least 8 characters
  Given I'm creating a new account
  When I enter a password with less than 8 characters
  Then I should see an error "Password must be at least 8 characters"

Scenario 2: Password must contain a number
  Given I'm creating a new account
  When I enter a password without any numbers
  Then I should see an error "Password must contain a number"
```

---

### The Risk: What Happens Without TDD Discipline

When AI generates code without TDD constraints, it tends to be "helpful" beyond the specification:

**Developer**: _"AI, implement password validation"_

**AI without constraints**: _"Here's a comprehensive solution:"_

```typescript
type ValidationResult = { isValid: boolean; errors: string[] }

class PasswordValidator {
  validate(password: string): ValidationResult {
    const errors = []

    // Length check (actually in specification)
    if (password.length < 8) {
      errors.push("Password must be at least 8 characters")
    }

    // AI adds these without being asked!
    if (!/[A-Z]/.test(password)) {
      errors.push("Password must contain an uppercase letter")
    }

    if (!/[0-9]/.test(password)) {
      errors.push("Password must contain a number")
    }

    if (!/[!@#$%^&*]/.test(password)) {
      errors.push("Password must contain a special character")
    }

    // Even more "helpful" additions
    if (password.length > 64) {
      errors.push("Password too long")
    }

    if (this.isCommonPassword(password)) {
      errors.push("Password is too common")
    }

    return { isValid: errors.length === 0, errors }
  }

  private isCommonPassword(password: string): boolean {
    const commonPasswords = ["password", "12345678" /* ... */]
    return commonPasswords.includes(password.toLowerCase())
  }
}
```

**The problems:**

- ‚ùå Spec asked for 2 validation rules (length + number)
- ‚ùå AI added 4 extra unauthorized rules (uppercase, special char, max length, common password)
- ‚ùå Untested edge cases shipped to production
- ‚ùå Users complain their valid passwords are rejected
- ‚ùå Business never approved these rules

You've shipped untested, unapproved features breaking real users. Passwords like `"password123"` are perfectly valid per the actual spec (over 8 characters, contains number), but the AI's extra rules incorrectly reject it for missing uppercase and special characters that were never required.

---

### How AAID Enforces TDD Discipline

Now let's see the same scenario with `AAID` rules guiding the AI through proper TDD.

> üí° **How AAID actually works**: As described in [Level 2](./2.md), the AI reads the rules file and follows TDD discipline. After each phase, it stops and asks if you want to continue. You simply say for example "yes", "go" or provide guidance.
>
> If the AI ignore the rules file‚Äîit unfortunately happens sometimes‚Äî you can use commands like `/refactor-&-stop` to get it back on track.

**An example TDD test list** (guided by the BDD scenarios):

```typescript
describe("PasswordValidator", () => {
  it.skip("should reject passwords that are too short")
  it.skip("should accept passwords at minimum length")
  it.skip("should reject passwords without numbers")
})
```

Un-skip and implement these one at a time through RED ‚Üí GREEN ‚Üí REFACTOR cycles. Watch how the tests drive minimal, focused code.

---

<a id="cycle-1"></a>

## üîÑ Cycle 1: First Test (Invalid Password)

### üî¥ RED: Write Failing Test

- **AI** (following AAID rules): "_Let me un-skip the first test and implement it._"

```typescript
describe("PasswordValidator", () => {
  it("should reject passwords that are too short", () => {
    // Given
    const validator = new PasswordValidator()
    const invalidPassword = "abc"

    // When
    const result = validator.validate(invalidPassword)

    // Then
    expect(result.isValid).toBe(false)
    expect(result.errors).toContain("Password must be at least 8 characters")
  })
})
```

> üí° **Note**: These tests check exact error message strings for simplicity. In production, you might use error codes or check for key concepts instead of exact wording. This tutorial keeps it simple to focus on the TDD workflow.

**Run test**: ‚ùå Fails (PasswordValidator doesn't exist)

- **AI stops**: "_Test is failing as expected. Should we proceed to GREEN phase?_"
- **You**: "_yes_" (or provide feedback if changes needed)

---

### üü¢ GREEN: Make It Pass (The Simplest Way Possible)

- **AI**: "_Now I'll write the minimum code to make the test pass:_"

```typescript
type ValidationResult = { isValid: boolean; errors: string[] }

class PasswordValidator {
  validate(password: string): ValidationResult {
    return {
      isValid: false,
      errors: ["Password must be at least 8 characters"]
    }
  }
}
```

**Run tests**: ‚úÖ All pass

**Why hardcode?** With only ONE test, you don't know what the general pattern is yet. This is Kent Beck's "Fake It" principle: hardcode the simplest thing that passes.

- **AI stops**: "_Test passes with this hardcoded implementation. Should we proceed to REFACTOR phase?_"
- **You**: "_yes_"

---

### üßº REFACTOR: Improve Code Quality

- **AI**: "_The hardcoded number 8 could be extracted as a constant for better maintainability. Should I refactor this?_"
- **You**: "_yes_"
- **AI**: "_Refactoring to extract the constant:_"

```typescript
type ValidationResult = { isValid: boolean; errors: string[] }

class PasswordValidator {
  private readonly MIN_LENGTH = 8

  validate(password: string): ValidationResult {
    return {
      isValid: false,
      errors: [`Password must be at least ${this.MIN_LENGTH} characters`]
    }
  }
}
```

**Run tests**: ‚úÖ All pass

- **AI stops**: "_Tests still pass after refactoring. Ready for the next test?_"
- **You**: "_let's make the min length configurable, with 8 as default_"
- **AI**: "_Should I add a constructor parameter?_"
- **You**: "_wait, that's new behavior. let's write a test for it first_"
- **AI**: "_Good discipline! I'll add that to our test list._"

**Updated test list:**

```typescript
describe("PasswordValidator", () => {
  ‚úÖ it("should reject passwords that are too short")
  it.skip("should respect custom minimum length")  // ‚Üê Added
  it.skip("should accept passwords at minimum length")
  it.skip("should reject passwords without numbers")
})
```

> üí° **Living Test List**: The test list isn't carved in stone. Add tests as you discover behavior that needs verification, like configurability here.
>
> **TDD Law #1 in Action** ("Write no production code without a failing test first"): The dialogue shows stopping to write a test before implementing the constructor. The AI usually catches this from AAID rules, but you're the final safeguard ensuring discipline stays solid.

---

<a id="cycle-2"></a>

## üîÑ Cycle 2: Test Custom Minimum Length

| ‚òùÔ∏è                                                                                                                                                                                                                                                                          |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **But configurability wasn't in the BDD spec!** That's okay; unit tests guide code quality and can add tests beyond business specs (only acceptance tests must map 1:1 to specs). Since this changes observable behavior (public API accepts a parameter), it needs a test. |

### üî¥ RED: Write Failing Test

- **AI**: "_Un-skipping the configurability test:_"

```typescript
describe("PasswordValidator", () => {
  // ... previous test ...

  it("should respect custom minimum length", () => {
    // Given
    const validator = new PasswordValidator(10)
    const passwordBelowMinimum = "abcdefghi"

    // When
    const result = validator.validate(passwordBelowMinimum)

    // Then
    expect(result.isValid).toBe(false)
    expect(result.errors).toContain("Password must be at least 10 characters")
  })
})
```

**Run tests**: ‚ùå Fails (`PasswordValidator` constructor doesn't exist yet)

- **AI stops**: "_Test fails as expected. The validator doesn't support custom lengths yet. Ready for GREEN?_"
- **You**: "_make it take an object instead_"
- **AI**: "_I'll update the test to use an object parameter:_"

```typescript
describe("PasswordValidator", () => {
  // ... previous test ...

  it("should respect custom minimum length", () => {
    // Given
    const validator = new PasswordValidator({ minLength: 10 })
    const passwordBelowMinimum = "abcdefghi"

    // When
    const result = validator.validate(passwordBelowMinimum)

    // Then
    expect(result.isValid).toBe(false)
    expect(result.errors).toContain("Password must be at least 10 characters")
  })
})
```

> üí° **Test-Driven Design**: See how the test is the first user of your code? RED is where you design the API; how it _should_ be used before implementing how it works.

**Run tests**: ‚ùå Still fails (constructor doesn't exist yet)

- **AI stops**: "_Test updated. Still fails as expected. Ready for GREEN?_"
- **You**: "_yes_"

---

### üü¢ GREEN: Add Constructor Parameter

- **AI**: "_I'll add an optional constructor parameter. Making it optional means the first test continues to pass without changes:_"

```typescript
// (ValidationResult type unchanged from previous step)
type PasswordValidatorOptions = { minLength: number }

class PasswordValidator {
  private readonly MIN_LENGTH: number

  constructor(options?: PasswordValidatorOptions) {
    this.MIN_LENGTH = options?.minLength ?? 8
  }

  validate(password: string): ValidationResult {
    return {
      isValid: false,
      errors: [`Password must be at least ${this.MIN_LENGTH} characters`]
    }
  }
}
```

> üí° **Note**: For brevity, we'll omit unchanged type definitions in subsequent code blocks.

**Run tests**: ‚úÖ Both tests pass (first uses default 8, second uses custom 10)

- **AI stops**: "_All tests pass with the configurable constructor. Ready for REFACTOR?_"
- **You**: "_yes_"

---

### üßº REFACTOR: Already Clean

- **AI**: "_Code is clean. No refactoring needed. Ready for the next test?_"
- **You**: "_yes_"

---

<a id="cycle-3"></a>

## üîÑ Cycle 3: Valid Password Test

Watch how this test **forces** real validation logic (triangulation!).

### üî¥ RED: Add Test for Valid Password

- **AI**: "_Un-skipping the next test:_"

```typescript
describe("PasswordValidator", () => {
  // ... previous tests ...

  it("should accept passwords at minimum length", () => {
    // Given
    const validator = new PasswordValidator()
    const validPassword = "abcdefgh"

    // When
    const result = validator.validate(validPassword)

    // Then
    expect(result.isValid).toBe(true)
    expect(result.errors.length).toBe(0)
  })
})
```

**Run tests**: ‚ùå Fails (hardcoded response always returns invalid)

- **AI stops**: "_New test fails as expected. Should we proceed to GREEN?_"
- **You**: "_yes_"

---

### üü¢ GREEN: Now Real Logic Is Needed

- **AI**: "_The hardcoded response won't work for both scenarios. I need to generalize and introduce actual logic:_"

This is **triangulation**: multiple tests revealing the general pattern.

```typescript
// (types unchanged)

class PasswordValidator {
  private readonly MIN_LENGTH: number

  constructor(options?: PasswordValidatorOptions) {
    this.MIN_LENGTH = options?.minLength ?? 8
  }

  validate(password: string): ValidationResult {
    const errors: string[] = []

    if (password.length < this.MIN_LENGTH) {
      errors.push(`Password must be at least ${this.MIN_LENGTH} characters`)
    }

    return { isValid: errors.length === 0, errors }
  }
}
```

**Run tests**: ‚úÖ All three tests pass

**The "aha!" moment**: The test **forced** actual validation logic. You couldn't fake it anymore: two tests demanded real behavior. This is how TDD keeps code minimal and focused.

- **AI stops**: "_All three tests pass with real validation logic. Should we proceed to REFACTOR?_"
- **You**: "_yes_"

---

### üßº REFACTOR: Still Clean

- **AI**: "_The code is clear and simple. I don't see any improvements needed. Proceed to RED for the next test?_"
- **You**: "_yes_"

---

**üí° The TDD boundary at work**: You've completed Scenario 1 (length validation). Notice what's **NOT** in the code:

- ‚ùå No uppercase requirement (wasn't in spec)
- ‚ùå No special character requirement (wasn't in spec)
- ‚ùå No "common password" check (wasn't in spec)
- ‚ùå No max length limit (wasn't in spec)

Without TDD, the AI added all of these "helpfully." With TDD, the test defines the boundary. No test? No code.

---

**Progress check**: You've completed the first three items from your test list:

```typescript
describe("PasswordValidator", () => {
  ‚úÖ it("should reject passwords that are too short")
  ‚úÖ it("should respect custom minimum length")
  ‚úÖ it("should accept passwords at minimum length")
  it.skip("should reject passwords without numbers")  // ‚Üê Next
})
```

The code is clean, all tests pass. Let's un-skip the fourth test.

<a id="cycle-4"></a>

## üîÑ Cycle 4: Number Validation Test

Time to implement Scenario 2: "Password must contain at least one number."

### üî¥ RED: Add Test for Number Validation

- **AI**: "_Un-skipping the final test:_"

```typescript
describe("PasswordValidator", () => {
  // ... previous tests ...

  it("should reject passwords without numbers", () => {
    // Given
    const validator = new PasswordValidator()
    const passwordWithoutNumber = "abcdefgh"

    // When
    const result = validator.validate(passwordWithoutNumber)

    // Then
    expect(result.isValid).toBe(false)
    expect(result.errors).toContain("Password must contain a number")
  })
})
```

**Run tests**: ‚ùå

- **AI stops**: "_Test fails as expected. Should we proceed to GREEN?_"
- **You**: "_yes_"

---

### üü¢ GREEN: Add Number Check

```typescript
// (types unchanged)

class PasswordValidator {
  private readonly MIN_LENGTH: number

  constructor(options?: PasswordValidatorOptions) {
    this.MIN_LENGTH = options?.minLength ?? 8
  }

  validate(password: string): ValidationResult {
    const errors: string[] = []

    if (password.length < this.MIN_LENGTH) {
      errors.push(`Password must be at least ${this.MIN_LENGTH} characters`)
    }

    if (!/[0-9]/.test(password)) {
      errors.push("Password must contain a number")
    }

    return { isValid: errors.length === 0, errors }
  }
}
```

**Run tests**: ‚úÖ All pass

- **AI stops**: "_All tests pass, move to REFACTOR?_"
- **You**: "_yes_"

---

### üßº REFACTOR: Developer Guides the Abstraction

- **AI**: "_The code is clean. I don't see any improvements needed. Proceed to RED for the next test?_"
- **You**: "_no extract the validations into a private readonly rules array with concise arrow functions, add a type for the rule signature, and make validate public._"

> üí° It is perfectly normal that you and the AI don't always agree. Remember: **this is not vibe coding ‚Üí you are in charge**!
>
> In this case, you're explicit to teach the AI your design preferences. Often it will just "get it" from the provided context, but not always.

- **AI**: "_**You're absolutely right!!!** I'll refactor to that structure._"

```typescript
// (types from earlier, plus:)
type ValidationRule = (password: string) => string | undefined

class PasswordValidator {
  private readonly MIN_LENGTH: number

  constructor(options?: PasswordValidatorOptions) {
    this.MIN_LENGTH = options?.minLength ?? 8
  }

  private readonly rules: ValidationRule[] = [
    password =>
      password.length < this.MIN_LENGTH
        ? `Password must be at least ${this.MIN_LENGTH} characters`
        : undefined,
    password =>
      !/[0-9]/.test(password) ? "Password must contain a number" : undefined
  ]

  public validate(password: string): ValidationResult {
    const errors = this.rules
      .map(rule => rule(password))
      .filter(error => error !== undefined)

    return { isValid: errors.length === 0, errors }
  }
}
```

**Run tests**: ‚úÖ All still pass

- **AI stops**: "_Tests still pass after refactoring. The code is now more extensible! Proceed to RED for the next test?_"
- **You**: "_let's give the validation functions names for readability_"
- **AI**: "_Good point! I'll extract them as named methods:_"

```typescript
// (types unchanged)

class PasswordValidator {
  private readonly MIN_LENGTH: number

  constructor(options?: PasswordValidatorOptions) {
    this.MIN_LENGTH = options?.minLength ?? 8
  }

  private readonly validateMinLength: ValidationRule = password =>
    password.length < this.MIN_LENGTH
      ? `Password must be at least ${this.MIN_LENGTH} characters`
      : undefined

  private readonly validateContainsNumber: ValidationRule = password =>
    !/[0-9]/.test(password) ? "Password must contain a number" : undefined

  private readonly rules: ValidationRule[] = [
    this.validateMinLength,
    this.validateContainsNumber
  ]

  public validate(password: string): ValidationResult {
    const errors = this.rules
      .map(rule => rule(password))
      .filter(error => error !== undefined)

    return { isValid: errors.length === 0, errors }
  }
}
```

> üí° Notice how you are fully in charge, while the AI is generating the code? This is the beauty of the `AAID` **Developer Mindset**:
>
> 1. üß† **Don't abandon your brain**
> 2. ü™ú **Incremental Steps**

**Run tests**: ‚úÖ All still pass

- **AI stops**: "_Named methods make the rules more readable! All scenarios from the spec are covered. Feature complete!_"
- **You**: "_Great teamwork!_ üòô"

---

## The Result: All Problems Solved

Remember the AI-generated problematic code from the "The Risk: What Happens Without TDD Discipline" section above? Here's how `AAID` solved each problem:

| Problem                       | Without `AAID`                                     | With `AAID`                                          |
| ----------------------------- | -------------------------------------------------- | ---------------------------------------------------- |
| **Spec adherence**            | ‚ùå Spec asked for 2 rules, AI added 4 unauthorized | ‚úÖ Implemented only what's in spec (length + number) |
| **Testing coverage**          | ‚ùå Untested code shipped to production             | ‚úÖ Every line tested before shipping                 |
| **User impact**               | ‚ùå Valid passwords like "password123" rejected     | ‚úÖ All spec-compliant passwords work                 |
| **Unauthorized features**     | ‚ùå Business never approved these rules             | ‚úÖ Only implements spec-approved requirements        |
| **Code quality & complexity** | ‚ùå 40+ lines with unnecessary features             | ‚úÖ ~25 lines of clean, focused code                  |

**This demonstrates the Three Laws of TDD:**

1. **Write no production code without a failing test** ‚Üí Prevented unapproved features
2. **Write only enough test code to fail** ‚Üí Kept tests focused on spec scenarios
3. **Write only enough production code to pass** ‚Üí Stopped over-engineering

Test defines the boundary. No test? No code.

---

**üõë Checkpoint**: See how TDD discipline guards against AI over-engineering?

- **"Yes, this makes sense!"** ‚Üí Continue to [Level 5](./5.md) for next steps
- **"I want to try this"** ‚Üí Jump to [Get Started](./get-started.md) for setup
- **"Show me the workflow again"** ‚Üí Review [Level 3](./3.md)

The key point: TDD discipline focuses AI's capabilities in the right direction. Your reviews ensure it stays on track.

---

‚úÖ **Progress: 62%** | Next: Level 5 (5 minutes) - Will This Work for Me?

---

‚¨ÖÔ∏è Back to [AAID Onboarding Guide](../guide.md)
