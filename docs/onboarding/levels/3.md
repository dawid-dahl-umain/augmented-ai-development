## Onboarding Level 3: The Three Ways to Build

| Level 0 | Level 1 |   Level 2    |      Level 3       | Level 4 |    Level 5     |  Level 6  |  Level 7  | Start |
| :-----: | :-----: | :----------: | :----------------: | :-----: | :------------: | :-------: | :-------: | :---: |
|   ‚úÖ    |   ‚úÖ    |      ‚úÖ      |     üìç **YOU**     |   ‚è∏Ô∏è    |       ‚è∏Ô∏è       |    ‚è∏Ô∏è     |    ‚è∏Ô∏è     |  ‚è∏Ô∏è   |
| Problem | Mindset | How It Works | **The Three Ways** | Visual  | TDD Catches AI | Your Work | Demo Repo | Ready |

**‚è±Ô∏è Time: 5-7 minutes**

![Visual Overview of the Workflow](../../../assets/onboarding/3.webp)

The AAID workflow divides all development work into three ways to build, or three distinct Implementation Categories. Understanding which category you're working in determines your entire approach: how you test, what you mock, and what success looks like.

![AAID implementation categories](../../../assets/aaid-implementation-categories-s.webp)

### üéØ Way 1: Business Behavior (What Your App Does)

This is your core business logic: the behaviors that deliver value to users.

**Examples:**

- "User archives completed todo"
- "Player wins with three in a row"
- "Form validates email before submission"
- "Shopping cart calculates total with tax"

**Your approach:** TDD with unit tests (mocking all external dependencies)

**Why:** This is what your app exists to do. If these behaviors break, your app fails its purpose. Tests run in milliseconds with complete isolation.

### ‚öôÔ∏è Way 2: Technical Infrastructure (How It Connects)

These are the infrastructure elements that bridge your business logic to the outside world.

**Examples:**

- Database repository saves user data
- REST controller handles HTTP requests
- Redis cache stores session data
- Email adapter sends notifications

**Your approach:** TDD with integration tests (using real connections to dependencies you control)

**Why:** Infrastructure needs testing with actual connections to verify it really works. Mocking your own database is like testing a car without the engine.

> Any dependencies that are not under your control, like external APIs, are mocked.

### üëÅÔ∏è Way 3: Pure Presentation (How It Looks/Sounds/Feels)

This is the sensory experience: what users see, hear, or feel.

**Examples:**

- Button hover transitions to blue
- Success toast fades in smoothly
- Error text displays in red
- Victory sound plays at completion

**Your approach:** Manual validation (NO TDD!)

**Why:** You shouldn't automate testing of whether something "feels right" or "looks good". Only humans should judge these sensory implementation details.

---

### Why This Matters

Most developers (and AI assistants) mix these categories together. They test the wrong things, skip testing the right things, and end up with systems that are scary to change.

**Common Mistakes (and Why They Hurt):**

‚ùå **"I'll just test it manually"** (Way 1 needs TDD!)

- Spend 10 minutes manually testing after every change
- Miss the edge cases, e.g where discounts make total negative
- Six months later: afraid to touch "working" code

‚ùå **Mocking your own database** (Way 2 needs real connections!)

- Mock says everything works, real DB throws constraint error
- "Passes locally" but crashes in production
- Never actually tested the integration

‚ùå **Writing tests for button colors** (Way 3 doesn't use TDD!)

- Tests break every time designer tweaks the shade
- Pass/fail can't tell you if it looks good
- Wasting time automating human judgment

**The AAID Solution:**

‚úÖ **Way 1: Business logic gets unit tested**

- Tests run in milliseconds, not 10 minutes
- Edge cases caught before production
- Refactor with confidence

‚úÖ **Way 2: Infrastructure gets integration tested**

- Real database catches real problems
- No more "works on my machine"
- Actual integration verified

‚úÖ **Way 3: Presentation gets human review**

- Designers validate what actually matters
- No brittle tests to maintain
- Humans judge the human experience

### Frontend Work? All Three Categories Apply

Frontend development isn't special. The same three categories exist whether you're building React components or backend services:

**Way 1 Examples (Frontend business logic - TDD with unit tests):**

- Form validation rules
- State management logic
- Data transformation functions
- Computed values and derived state

**Way 2 Examples (Frontend infrastructure - TDD with integration tests):**

- API client adapters
- Local storage repositories
- WebSocket connection handlers
- Service worker caching

**Way 3 Examples (Frontend presentation - manual validation only):**

- CSS animations and transitions
- Color schemes and typography
- Layout and spacing
- Loading states and skeletons

The key: Separate what needs testing from what needs human eyes.

### How AAID Guides You

At Stage 1 of the AAID workflow, you'll ask yourself "What are you building?" Meaning, which of the three ways (Implementation Categories) applies to your current work. This determines:

1. **What context you provide** (business specs, technical docs, or design files)
2. **Which roadmap template you use** (`/ai-roadmap-template`, `/ai-technical-roadmap-template`, or `/ai-presentation-roadmap-template`)
3. **Which path through the workflow** (TDD with unit tests, TDD with integration tests, or implementation with manual validation)

The rules file guides the AI assistant to follow the right approach for your category.

---

**üõë Checkpoint**: Does the distinction make sense?

- **Yes, I see the three ways clearly** ‚Üí Continue to [Level 4](./4.md) to see the workflow diagram
- **I want examples for my specific work** ‚Üí Jump to [Level 6](./6.md) which addresses different scenarios
- **This seems complex** ‚Üí Remember: you're already doing this implicitly. AAID just makes it explicit

---

‚úÖ **Progress: 43%** | Next: Level 4 (5-10 minutes) - Visual Overview of the Workflow

---

‚¨ÖÔ∏è Back to [AAID Onboarding Guide](../guide.md)
